@startuml aa
skinparam classAttributeIconSize 0
skinparam roundcorner 10
skinparam shadowing false
skinparam defaultFontName "Segoe UI, Arial"
skinparam class {
  BackgroundColor PaleGreen
  ArrowColor SeaGreen
  BorderColor SeaGreen
}

' ===================================
' Classe Processador
' ===================================
class Processador {
  - NivelMemoria* primeiroNivel
  - PadraoAcessoMemoria* padraoAcesso
  - int ciclosTotais
  + Processador()
  + definirHierarquiaMemoria(NivelMemoria*) : void
  + definirPadraoAcesso(PadraoAcessoMemoria*) : void
  + executar() : void
  + obterCiclosTotais() : int
}

' ===================================
' Classe Hierarquia de Memória
' ===================================
class HierarquiaMemoria {
  - vector<NivelMemoria*> niveis
  - Processador* processador
  + HierarquiaMemoria()
  + adicionarNivel(NivelMemoria*) : void
  + definirProcessador(Processador*) : void
  + inicializar() : void
  + imprimirEstatisticas() : void
}

' ===================================
' Padrões de Acesso (Strategy Pattern)
' ===================================
abstract class PadraoAcessoMemoria {
  # int tamanhoBuffer
  # int quantidadeAcessos
  # int acessoAtual
  + PadraoAcessoMemoria(int tamanhoBuffer, int quantidadeAcessos)
  + temProximo() : bool
  + {abstract} obterProximoEndereco() : uint64_t
  + {abstract} ehEscrita() : bool
}

class PadraoSequencial {
  - int stride
  - uint64_t enderecoAtual
  + PadraoSequencial(int tamanhoBuffer, int quantidadeAcessos, int stride)
  + obterProximoEndereco() : uint64_t
  + ehEscrita() : bool
}

class PadraoAleatorio {
  - random_device rd
  - mt19937 gen
  + PadraoAleatorio(int tamanhoBuffer, int quantidadeAcessos)
  + obterProximoEndereco() : uint64_t
  + ehEscrita() : bool
}

' ===================================
' Níveis de Memória (Polimorfismo)
' ===================================
abstract class NivelMemoria {
  # string nome
  # int latencia
  # NivelMemoria* proximoNivel
  # Estatisticas stats
  + NivelMemoria(string nome, int latencia)
  + definirProximoNivel(NivelMemoria*) : void
  + {abstract} acessar(uint64_t endereco, bool ehEscrita) : ResultadoAcesso
  + obterLatencia() : int
  + obterNome() : string
  + {abstract} imprimirEstatisticas() : void
}

class Cache {
  - int associatividade
  - int tamanhoConjunto
  - int tamanhoLinha
  - int numeroConjuntos
  - PoliticaEscrita* politicaEscrita
  - vector<ConjuntoCache*> conjuntos
  - SubstituidorLRU* substituidor
  + Cache(string nome, int latencia, int associatividade, int tamanhoConjunto, int tamanhoLinha, PoliticaEscrita* politica)
  + acessar(uint64_t endereco, bool ehEscrita) : ResultadoAcesso
  + encontrarLinha(uint64_t endereco) : LinhaCache*
  + alocarLinha(uint64_t endereco) : void
  + atualizarLRU(int indiceConjunto, int indiceVia) : void
  + imprimirEstatisticas() : void
  - obterIndiceConjunto(uint64_t endereco) : int
  - obterTag(uint64_t endereco) : uint64_t
  - obterOffset(uint64_t endereco) : int
}

class MemoriaPrincipal {
  - int acessosLeitura
  - int acessosEscrita
  + MemoriaPrincipal(string nome, int latencia)
  + acessar(uint64_t endereco, bool ehEscrita) : ResultadoAcesso
  + imprimirEstatisticas() : void
}

' ===================================
' Estruturas da Cache
' ===================================
class ConjuntoCache {
  - vector<LinhaCache*> vias
  - int associatividade
  + ConjuntoCache(int associatividade)
  + encontrarLinha(uint64_t tag) : LinhaCache*
  + obterLinha(int indiceVia) : LinhaCache*
  + substituirLinha(int indiceVia, uint64_t tag) : void
  + estaCheia() : bool
}

class LinhaCache {
  - uint64_t tag
  - bool valida
  - bool suja
  - vector<uint8_t> dados
  + LinhaCache(int tamanhoLinha)
  + estaValida() : bool
  + estaSuja() : bool
  + obterTag() : uint64_t
  + definirTag(uint64_t tag) : void
  + definirValida(bool valida) : void
  + definirSuja(bool suja) : void
  + invalidar() : void
}

' ===================================
' Política de Substituição LRU
' ===================================
class SubstituidorLRU {
  - map<int, list<int>> listasLRU
  + SubstituidorLRU()
  + acessar(int indiceConjunto, int indiceVia) : void
  + obterVitima(int indiceConjunto) : int
  + atualizar(int indiceConjunto, int indiceVia) : void
}

' ===================================
' Políticas de Escrita (Strategy Pattern)
' ===================================
abstract class PoliticaEscrita {
  + {abstract} aoEscrever(Cache* cache, uint64_t endereco) : void
  + {abstract} aoRemover(Cache* cache, LinhaCache* linha) : void
}

class PoliticaWriteThrough {
  + aoEscrever(Cache* cache, uint64_t endereco) : void
  + aoRemover(Cache* cache, LinhaCache* linha) : void
}

class PoliticaWriteBack {
  + aoEscrever(Cache* cache, uint64_t endereco) : void
  + aoRemover(Cache* cache, LinhaCache* linha) : void
}

' ===================================
' Estatísticas
' ===================================
class Estatisticas {
  - int acessosLeitura
  - int acessosEscrita
  - int hits
  - int misses
  + Estatisticas()
  + registrarLeitura() : void
  + registrarEscrita() : void
  + registrarHit() : void
  + registrarMiss() : void
  + obterAcessosLeitura() : int
  + obterAcessosEscrita() : int
  + obterHits() : int
  + obterMisses() : int
  + obterTaxaMiss() : double
  + resetar() : void
}

' ===================================
' Resultado de Acesso
' ===================================
class ResultadoAcesso {
  + bool hit
  + int latenciaTotal
  + ResultadoAcesso(bool hit, int latencia)
}

' ===================================
' RELACIONAMENTOS
' ===================================

' Processador
Processador --> NivelMemoria : primeiroNivel
Processador --> PadraoAcessoMemoria : usa

' HierarquiaMemoria
HierarquiaMemoria --> NivelMemoria : gerencia
HierarquiaMemoria --> Processador : controla

' Padrões de Acesso - Herança
PadraoAcessoMemoria <|-- PadraoSequencial
PadraoAcessoMemoria <|-- PadraoAleatorio

' Níveis de Memória - Herança
NivelMemoria <|-- Cache
NivelMemoria <|-- MemoriaPrincipal
NivelMemoria --> NivelMemoria : proximoNivel
NivelMemoria *-- Estatisticas : possui

' Cache
Cache *-- ConjuntoCache : contém
Cache --> PoliticaEscrita : usa
Cache --> SubstituidorLRU : usa

' ConjuntoCache
ConjuntoCache *-- LinhaCache : contém

' Políticas de Escrita - Herança
PoliticaEscrita <|-- PoliticaWriteThrough
PoliticaEscrita <|-- PoliticaWriteBack

' Retorno
NivelMemoria ..> ResultadoAcesso : retorna

@enduml